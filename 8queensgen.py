import random
import os
from math import comb

#This function takes our position array and prints it to the console
def initBoard(bVals):
    for x in range(0,8):
        for y in range((8*x), (8*x+8)):
            print('|', bVals[y], end= "")
        print('|')
        for t in range(0,8):
            print('+--', end="")
        print('+')

#Generates a board for a given list of queens.
def generateBoard(queens):
    bVals = ['0' for x in range(64)]
    for i in queens:
        bVals[i] = 'Q'
    return bVals

#Generate an array where queens are randomly placed on a unique column
def generateRandomProblem():
    queens = [0,1,2,3,4,5,6,7]
    for i in range(0,8):
        rand = random.randrange(0,8)
        queens[i] += rand*8
    return queens

"""
This function calculates the heuristic cost associated with a given board
configuration. It begins by scanning each row, column, and diagonal
(we'll call them lines). If there is more than one queen present in
a given line, we take the total number of queens in that line, denoted n,
and calculate choose(n,2). This gives us the amount of pairwise attacks
in a line. Note that it is considered an attack even if there is an
intermediate piece between any two. To get the total heuristic cost, we simply
sum the number of pairwise attacks for all lines in the board.
"""
def hCost(bVals):
    attacks = 0
    size = 8

    # Check rows
    for i in range(size):
        numQueens = 0
        for j in range(size):
            pos = (size * i) + j
            if bVals[pos] == 'Q':
                numQueens += 1
        if numQueens > 1:
            attacks += comb(numQueens, 2)

    # Check columns
    for i in range(size):
        numQueens = 0
        for j in range(size):
            pos = (i + size * j)
            if bVals[pos] == 'Q':
                numQueens += 1
        if numQueens > 1:
            attacks += comb(numQueens, 2)

    # Check downward diagonals (top-left to bottom-right)
    for start in range(size):
        numQueens = 0
        x, y = 0, start
        while x < size and y < size:
            if bVals[x * size + y] == 'Q':
                numQueens += 1
            x += 1
            y += 1
        if numQueens > 1:
            attacks += comb(numQueens, 2)

    # From first column (excluding the first cell)
    for start in range(1, size):  
        numQueens = 0
        x, y = start, 0
        while x < size and y < size:
            if bVals[x * size + y] == 'Q':
                numQueens += 1
            x += 1
            y += 1
        if numQueens > 1:
            attacks += comb(numQueens, 2)

    # Check upward diagonals (bottom-left to top-right)
    for start in range(size):
        numQueens = 0
        x, y = size - 1, start
        while x >= 0 and y < size:
            if bVals[x * size + y] == 'Q':
                numQueens += 1
            x -= 1
            y += 1
        if numQueens > 1:
            attacks += comb(numQueens, 2)

    # From first column (excluding the last cell)
    for start in range(size - 2, -1, -1):  
        numQueens = 0
        x, y = start, 0
        while x >= 0 and y < size:
            if bVals[x * size + y] == 'Q':
                numQueens += 1
            x -= 1
            y += 1
        if numQueens > 1:
            attacks += comb(numQueens, 2)

    return attacks

"""
This function first calculates the fitness score of a given popluation.
Specifically, the fitness score is equal to 28 - hcost(bVals). Where bVals
corresponds to the board generated by a given member of the population.
Once this is done, we return the indices of the floor(n/2) most fit members of
the population.
"""
def selection(pop):

    #array to store fitness of population
    fitness = []

    for x in pop:
        ind = pop.index(x)
        b = generateBoard(x)
        fitScore = 28 - hCost(b)
        fitness.append((fitScore, ind))
    
    #sort the index from highest to lowest values based on fitness score:
    fitness.sort(key=lambda y: y[0], reverse=True)


    #parentsInd is an array of index value in pop for the most fit members
    parentsInd = [t[1] for t in fitness[:10]]

    #pull each list of queens from pop and store them in parents array
    parents = []
    for i in parentsInd:
        parents.append(pop[i])
    return parents

#this function produces an offspring of two parents and allows for mutations
def reproduce(q1,q2):
    child = []

    for i in range(8):
        if (i < 2):
            child.append(q1[i])
        else:
            child.append(q2[i])
    #Generate 1/10 chance of mutation
    mutation = random.randrange(0,10)
    if (mutation == 3):
        randSelect = random.randrange(8)
        qStar = child[randSelect]
        col = qStar % 8

        #Generate legal moves for a qStar mutation
        legalMoves = []
        for i in range(8):
            if(not(col+8*i == qStar)):
                legalMoves.append(col+8*i)
            else:
                pass
        rand2 = random.randrange(0,len(legalMoves))
        mutMove = legalMoves[rand2]
        child[randSelect] = mutMove
    else:
        pass
    return child

#selects best fit member of a population
def bestFit(pop):
    fitness = []
    for x in pop:
        ind = pop.index(x)
        b = generateBoard(x)
        fitScore = 28 - hCost(b)
        fitness.append((fitScore, ind))

    fitness.sort(key=lambda y: y[0], reverse=True)
    #this is a tuple with the fitness score and index of best fit
    bestQueens = fitness[0]
    return bestQueens
           
#Generate the population:
population = [generateRandomProblem() for i in range(100)]
generations = 0

solution = bestFit(population)
while (generations < 200 and not(solution[0] == 28)):
    myParents = selection(population)
    population.clear()
    population = myParents.copy()

    #generate all unique combinations of parents:
    pCombinations = []
    n = len(myParents)
    for i in range(n):
        for j in range(i+1, n):
            pCombinations.append((myParents[i], myParents[j]))
    #generate children of these combinations:
    for i in range(len(pCombinations)):
        newKid = reproduce(pCombinations[i][0], pCombinations[i][1])
        population.append(newKid)
    solution = bestFit(population)
    generations += 1
print(solution)

popIndex = solution[1]
wQueens = population[popIndex]
wBoard = generateBoard(wQueens)
initBoard(wBoard)




